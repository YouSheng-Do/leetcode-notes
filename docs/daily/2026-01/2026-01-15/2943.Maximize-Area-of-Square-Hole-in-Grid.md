# [2943. Maximize Area of Square Hole in Grid](https://leetcode.com/problems/maximize-area-of-square-hole-in-grid/)
## ğŸ§  é¡Œç›®æ€è·¯ï¼ˆIntuitionï¼‰

- **ä¸€å¥è©±ç¸½çµ**ï¼šæœ€å¤§æ­£æ–¹å½¢æ´çš„é‚Šé•·ç”±ã€Œæ°´å¹³ã€èˆ‡ã€Œå‚ç›´ã€å…©æ–¹å‘å¯æ‰“é€šçš„æœ€å¤§é€£é€šé•·åº¦å…±åŒæ±ºå®šï¼Œå–å…©è€…æœ€å°å¾Œå¹³æ–¹å³ç‚ºç­”æ¡ˆã€‚
- **è§€å¯Ÿ**
  - ç§»é™¤çš„ bar åªæœ‰åœ¨ **index é€£çºŒ**ï¼ˆä¾‹å¦‚ `k, k+1, k+2`ï¼‰æ™‚ï¼Œæ‰èƒ½æŠŠå¤šå€‹ç›¸é„°å°æ ¼ã€Œæ‰“é€šã€æˆæ›´å¤§çš„æ´ã€‚
  - å°æ–¼æŸä¸€æ–¹å‘ï¼Œè‹¥å­˜åœ¨é•·åº¦ç‚º `removebars` çš„é€£çºŒ bar åºåˆ—è¢«ç§»é™¤ï¼Œå‰‡è©²æ–¹å‘æ´çš„**é‚Šé•·**æœƒæ˜¯ï¼š`removebars + 2`
    - `+2` ä¾†è‡ªæ–¼ï¼šé€£çºŒç§»é™¤ `removebars` æ ¹ bar æœƒå¤šæ‰“é€š `removebars` å€‹é–“éš”ï¼Œä½†æœ€åŸºæœ¬ä»æœ‰å…©å´é‚Šç•Œå½¢æˆè‡³å°‘ 2 çš„é‚Šé•·ã€‚
  - æ­£æ–¹å½¢å¿…é ˆåŒæ™‚æ»¿è¶³æ°´å¹³ã€å‚ç›´é‚Šé•·ï¼Œå› æ­¤æœ€å¤§æ­£æ–¹å½¢é‚Šé•·ç‚ºï¼š
    - `side = min(hMaxLen, vMaxLen)`
    - é¢ç©ç‚º `side^2`
- **é™åˆ¶åˆ†æ**
  - éœ€è¦æ‰¾ã€Œæœ€é•·é€£çºŒæ®µã€ï¼šå…ˆæ’åºå¾Œç·šæ€§æƒæå³å¯ã€‚
  - `hBars`ã€`vBars` å¯èƒ½ç‚ºç©ºæˆ–é•·åº¦ 1ï¼Œæ­¤æ™‚ç„¡é€£çºŒæ®µï¼Œæœ€å°æ´é‚Šé•·ç¶­æŒ 2ã€‚

---

## æ ¸å¿ƒæ¦‚å¿µï¼ˆKey Conceptsï¼‰

- **å®šç¾©**
  - `hBars`ï¼šè¢«ç§»é™¤çš„æ°´å¹³ bars çš„ç´¢å¼•é›†åˆ
  - `vBars`ï¼šè¢«ç§»é™¤çš„å‚ç›´ bars çš„ç´¢å¼•é›†åˆ
  - `l`ï¼šç›®å‰æƒæåˆ°çš„é€£çºŒæ®µæ‰€å°æ‡‰çš„æ´é‚Šé•·  
    - `l = removebars + 2`
  - `hMaxLen`ï¼šæ°´å¹³å‘å¯å½¢æˆçš„æœ€å¤§æ´é‚Šé•·
  - `vMaxLen`ï¼šå‚ç›´å‘å¯å½¢æˆçš„æœ€å¤§æ´é‚Šé•·
- **æ¼”ç®—æ³•**
  1. å° `hBars`ã€`vBars` æ’åº
  2. å„è‡ªæƒææ‰¾æœ€é•·ã€Œé€£çºŒ +1ã€æ®µï¼Œä¸¦ç”¨ `l` ç›´æ¥ç¶­è­·æ´é‚Šé•·
     - è‹¥ `bars[i] == bars[i-1] + 1`ï¼Œè¡¨ç¤ºé€£çºŒæ®µå»¶ä¼¸ï¼Œ`++l`
     - å¦å‰‡ä¸­æ–·ï¼Œé‡è¨­ `l = 2`
  3. `side = min(hMaxLen, vMaxLen)`ï¼Œç­”æ¡ˆ `side * side`

---

## â±ï¸ è¤‡é›œåº¦åˆ†æï¼ˆComplexityï¼‰

* **æ™‚é–“è¤‡é›œåº¦**ï¼š`O(H log H + V log V)`  
  - `H = hBars.size()`, `V = vBars.size()`ï¼ˆæ’åºæˆæœ¬ç‚ºä¸»ï¼Œæƒæç‚ºç·šæ€§ï¼‰
* **ç©ºé–“è¤‡é›œåº¦**ï¼š`O(1)`ï¼ˆä¸è¨ˆæ’åºé¡å¤–ç©ºé–“ï¼‰

---

## âœ… æœ€çµ‚å¯¦ä½œï¼ˆCodeï¼‰

```cpp
class Solution {
public:
    int maximizeSquareHoleArea(int n, int m, vector<int>& hBars, vector<int>& vBars) {
        // Remove all the bars make sure we can get the maximum area.
        // The square area should be make up by removing continuous bars both in vertical and horizontal.
        // So, the problem can be solved by find the length of the longest continuous bars in vertical and horizontal

        // First, sort hBars and vBars.
        // Second, find the length of the longest continuous bars of hBars and vBars.
        // return the square of the minimum of them.

        sort(hBars.begin(), hBars.end());
        sort(vBars.begin(), vBars.end());

        int vMaxLen = 2;
        int hMaxLen = 2;

        int l = 2; // l means "side length of the hole by continuously removing segments (= length of continuous bars + 2)"
        for (int i = 1; i < (int)hBars.size(); ++i) {
            if (hBars[i] == hBars[i - 1] + 1) ++l;
            else l = 2;
            hMaxLen = max(l, hMaxLen);
        }

        l = 2;
        for (int i = 1; i < (int)vBars.size(); ++i) {
            if (vBars[i] == vBars[i - 1] + 1) ++l;
            else l = 2;
            vMaxLen = max(l, vMaxLen);
        }

        int ans = min(hMaxLen, vMaxLen);

        return ans * ans;
    }
};
```

---

## ğŸ“ å°çµï¼ˆSummaryï¼‰

* é€™é¡Œçš„é—œéµåœ¨æ–¼ï¼š**æ´çš„é‚Šé•·åªæœƒè¢«ã€Œé€£çºŒç§»é™¤çš„ barsã€æ“´å¼µ**ï¼Œå› æ­¤å•é¡Œå¯è½‰åŒ–ç‚ºæ‰¾å‡ºæ°´å¹³èˆ‡å‚ç›´å…©æ–¹å‘çš„æœ€é•·é€£çºŒæ®µã€‚
* é€£çºŒæ®µé•·åº¦ `removebars + 2` å°æ‡‰æ´é‚Šé•· `l`ï¼Œæœ€å¾Œæ­£æ–¹å½¢ç”±çŸ­æ¿æ±ºå®šï¼š`min(hMaxLen, vMaxLen)^2`ã€‚

---
